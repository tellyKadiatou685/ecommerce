// lib/services/merchant_stats_service.dart - SERVICE CORRIG√â SANS CONFLIT D'IMPORTS

import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import '../models/merchant_stats_model.dart';
import '../models/order_model.dart';
import '../services/order_service.dart';
import 'api_config.dart';

class MerchantStatsService {
  static final MerchantStatsService _instance = MerchantStatsService._internal();
  factory MerchantStatsService() => _instance;
  MerchantStatsService._internal();

  // üÜï AJOUT: D√©pendance √† OrderService pour r√©cup√©rer les commandes
  final OrderService _orderService = OrderService();

  // Cache pour √©viter les appels r√©p√©t√©s
  MerchantStats? _cachedStats;
  DateTime? _lastCacheTime;
  static const Duration _cacheValidDuration = Duration(minutes: 5);

  /// Obtient le token d'authentification
  Future<String?> _getAuthToken() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      String? token = prefs.getString('auth_token');
      if (token == null) {
        token = prefs.getString('token');
        if (token == null) {
          token = prefs.getString('access_token');
        }
      }
      
      if (token == null) {
        print('‚ùå [STATS] Aucun token trouv√©');
        return null;
      }

      if (_isTokenExpired(token)) {
        print('‚ùå [STATS] Token expir√©');
        await _handleAuthError();
        return null;
      }

      return token;
    } catch (e) {
      print('‚ùå [STATS] Erreur r√©cup√©ration token: $e');
      return null;
    }
  }

  /// V√©rifie si le token JWT est expir√©
  bool _isTokenExpired(String token) {
    try {
      final parts = token.split('.');
      if (parts.length != 3) return true;

      final payload = json.decode(
        utf8.decode(base64Url.decode(base64Url.normalize(parts[1])))
      );

      final exp = payload['exp'] as int?;
      if (exp == null) return true;

      final expirationTime = DateTime.fromMillisecondsSinceEpoch(exp * 1000);
      return DateTime.now().isAfter(expirationTime);
    } catch (e) {
      print('‚ùå [STATS] Erreur validation token: $e');
      return true;
    }
  }

  /// G√®re les erreurs d'authentification
  Future<void> _handleAuthError() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('auth_token');
      await prefs.remove('user_data');
      await prefs.remove('token');
      await prefs.remove('user');
      print('‚ö†Ô∏è [STATS] Session expir√©e - donn√©es nettoy√©es');
      
      _clearCache();
    } catch (e) {
      print('‚ùå [STATS] Erreur lors du nettoyage: $e');
    }
  }

  /// V√©rifie si l'utilisateur est connect√©
  Future<bool> isUserLoggedIn() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final userStr = prefs.getString('user_data');
      final token = await _getAuthToken();
      
      return userStr != null && token != null;
    } catch (e) {
      print('‚ùå [STATS] Erreur v√©rification connexion: $e');
      return false;
    }
  }

  /// üìä M√âTHODE CORRIG√âE - R√âCUP√âRER LES STATISTIQUES DEPUIS LES COMMANDES
  Future<MerchantStats> getMerchantStats({bool forceRefresh = false}) async {
    try {
      print('üìä [STATS] R√©cup√©ration des statistiques marchand depuis les commandes');

      // V√©rifier le cache
      if (!forceRefresh && _isValidCache()) {
        print('‚úÖ [STATS] Utilisation du cache');
        return _cachedStats!;
      }

      if (!await isUserLoggedIn()) {
        throw OrderException(
          'NOT_LOGGED_IN',
          'Vous devez √™tre connect√© pour acc√©der aux statistiques'
        );
      }

      // üîß UTILISER OrderService pour r√©cup√©rer les commandes r√©elles
      final List<MerchantOrder> merchantOrders = await _orderService.getMerchantOrders();
      
      print('üìã [STATS] ${merchantOrders.length} commandes r√©cup√©r√©es pour calcul des statistiques');

      // üîß CALCULER LES STATISTIQUES √Ä PARTIR DES VRAIES DONN√âES
      final stats = _calculateStatsFromOrders(merchantOrders);
      
      // Mettre en cache
      _cacheStats(stats);
      
      print('‚úÖ [STATS] Statistiques calcul√©es: CA ${stats.formattedTotalRevenue}, ${stats.totalOrders} commandes');
      return stats;
      
    } on TimeoutException {
      throw OrderException(
        'TIMEOUT',
        'Le serveur ne r√©pond pas. R√©essayez plus tard.'
      );
    } on SocketException {
      throw OrderException(
        'NO_INTERNET',
        'Pas de connexion r√©seau. V√©rifiez votre connexion.'
      );
    } catch (e) {
      if (e is OrderException) {
        rethrow;
      }
      print('‚ùå [STATS] Erreur statistiques: $e');
      throw OrderException('UNKNOWN_ERROR', 'Erreur lors de la r√©cup√©ration des statistiques: $e');
    }
  }

  /// üÜï CALCUL DES STATISTIQUES √Ä PARTIR DES COMMANDES R√âELLES
  MerchantStats _calculateStatsFromOrders(List<MerchantOrder> orders) {
    print('üî¢ [STATS] Calcul des statistiques √† partir de ${orders.length} commandes');

    // Grouper par statut
    final pendingOrders = orders.where((o) => o.status == OrderStatus.pending).length;
    final confirmedOrders = orders.where((o) => o.status == OrderStatus.confirmed).length;
    final shippedOrders = orders.where((o) => o.status == OrderStatus.shipped).length;
    final deliveredOrders = orders.where((o) => o.status == OrderStatus.delivered).length;
    final canceledOrders = orders.where((o) => o.status == OrderStatus.canceled).length;

    // Calculer le revenu total (exclure les commandes annul√©es)
    final nonCanceledOrders = orders.where((o) => o.status != OrderStatus.canceled);
    final totalRevenue = nonCanceledOrders.fold<double>(0, (sum, order) => sum + order.totalAmount);
    
    // Calculer le taux de succ√®s (livr√© / total non annul√©)
    final nonCanceledCount = nonCanceledOrders.length;
    final successRate = nonCanceledCount > 0 
        ? (deliveredOrders / nonCanceledCount) * 100 
        : 0.0;

    // Calculer le panier moyen (bas√© sur les commandes non annul√©es)
    final averageOrderValue = nonCanceledCount > 0 
        ? totalRevenue / nonCanceledCount 
        : 0.0;

    // üîß Convertir MerchantOrder en RecentOrder pour l'affichage
    final sortedOrders = List<MerchantOrder>.from(orders)
      ..sort((a, b) => b.createdAt.compareTo(a.createdAt));
    
    final recentOrders = sortedOrders
        .take(10)
        .map((merchantOrder) => _convertToRecentOrder(merchantOrder))
        .toList();

    // G√©n√©rer le graphique des revenus
    final revenueChart = _generateRevenueChartFromOrders(orders);

    // Calculer le top produits
    final topProducts = _generateTopProductsFromOrders(orders);

    final stats = MerchantStats(
      totalRevenue: totalRevenue,
      totalOrders: orders.length,
      pendingOrders: pendingOrders,
      confirmedOrders: confirmedOrders,
      shippedOrders: shippedOrders,
      deliveredOrders: deliveredOrders,
      canceledOrders: canceledOrders,
      successRate: successRate,
      averageOrderValue: averageOrderValue,
      topProducts: topProducts,
      recentOrders: recentOrders,
      revenueChart: revenueChart,
    );

    print('üìä [STATS] Statistiques calcul√©es - CA: ${stats.formattedTotalRevenue}, Succ√®s: ${stats.formattedSuccessRate}');
    return stats;
  }

  /// üîß CONVERSION MerchantOrder ‚Üí RecentOrder avec toutes les donn√©es client
  RecentOrder _convertToRecentOrder(MerchantOrder merchantOrder) {
    return RecentOrder(
      id: merchantOrder.id,
      clientName: merchantOrder.client.fullName,
      
      // üîß IMPORTANT: R√©cup√©rer le vrai num√©ro de t√©l√©phone depuis l'API
      clientPhone: merchantOrder.client.phoneNumber,
      clientEmail: merchantOrder.client.email,
      
      totalAmount: merchantOrder.totalAmount,
      status: merchantOrder.status.value,
      createdAt: merchantOrder.createdAt,
      
      // üîß Convertir les items en products pour le modal
      products: merchantOrder.items.map((item) => {
        'name': item.product.name,
        'quantity': item.quantity,
        'price': item.price,
        'subtotal': item.subtotal,
        'imageUrl': item.product.firstImageUrl,
      }).toList(),
    );
  }

  /// üîß G√âN√âRER GRAPHIQUE DE REVENUS BAS√â SUR LES VRAIES DONN√âES
  List<RevenueChartData> _generateRevenueChartFromOrders(List<MerchantOrder> orders) {
    final Map<String, double> dailyRevenue = {};
    final Map<String, int> dailyOrderCount = {};
    
    // Initialiser les 7 derniers jours
    final now = DateTime.now();
    for (int i = 6; i >= 0; i--) {
      final date = now.subtract(Duration(days: i));
      final dateKey = _formatDateKey(date);
      dailyRevenue[dateKey] = 0.0;
      dailyOrderCount[dateKey] = 0;
    }

    // Calculer les revenus r√©els par jour (exclure les annul√©es)
    for (final order in orders) {
      if (order.status == OrderStatus.canceled) continue; // Exclure les annul√©es
      
      final orderDate = order.createdAt;
      final dateKey = _formatDateKey(orderDate);
      
      if (dailyRevenue.containsKey(dateKey)) {
        dailyRevenue[dateKey] = (dailyRevenue[dateKey] ?? 0) + order.totalAmount;
        dailyOrderCount[dateKey] = (dailyOrderCount[dateKey] ?? 0) + 1;
      }
    }

    // Convertir en RevenueChartData
    return dailyRevenue.entries.map((entry) {
      return RevenueChartData(
        date: DateTime.parse(entry.key),
        revenue: entry.value,
        orderCount: dailyOrderCount[entry.key] ?? 0,
      );
    }).toList()..sort((a, b) => a.date.compareTo(b.date));
  }

  /// üîß G√âN√âRER TOP PRODUITS BAS√â SUR LES VRAIES DONN√âES
  List<TopProduct> _generateTopProductsFromOrders(List<MerchantOrder> orders) {
    final Map<int, Map<String, dynamic>> productStats = {};

    // Analyser tous les produits des commandes non annul√©es
    for (final order in orders) {
      if (order.status == OrderStatus.canceled) continue; // Exclure les annul√©es
      
      for (final item in order.items) {
        final productId = item.product.id;
        
        if (!productStats.containsKey(productId)) {
          productStats[productId] = {
            'name': item.product.name,
            'totalSold': 0,
            'totalRevenue': 0.0,
            'orderCount': 0,
          };
        }
        
        productStats[productId]!['totalSold'] += item.quantity;
        productStats[productId]!['totalRevenue'] += item.subtotal;
        productStats[productId]!['orderCount'] += 1;
      }
    }

    // Convertir en TopProduct et trier par revenus
    final topProducts = productStats.entries.map((entry) {
      return TopProduct(
        productId: entry.key,
        productName: entry.value['name'],
        totalSold: entry.value['totalSold'],
        totalRevenue: entry.value['totalRevenue'].toDouble(),
        orderCount: entry.value['orderCount'],
      );
    }).toList();

    // Trier par revenus d√©croissants et prendre le top 5
    topProducts.sort((a, b) => b.totalRevenue.compareTo(a.totalRevenue));
    return topProducts.take(5).toList();
  }

  /// üîß M√âTHODES CONSERV√âES MAIS MODIFI√âES POUR UTILISER LES VRAIES DONN√âES

  /// üèÜ R√âCUP√âRER LE TOP 5 DES PRODUITS (utilise maintenant les commandes)
  Future<List<TopProduct>> getTopProducts() async {
    try {
      print('üèÜ [STATS] Calcul du top 5 produits depuis les commandes');
      
      final merchantOrders = await _orderService.getMerchantOrders();
      final topProducts = _generateTopProductsFromOrders(merchantOrders);
      
      print('‚úÖ [STATS] ${topProducts.length} top produits calcul√©s');
      return topProducts;
      
    } catch (e) {
      if (e is OrderException) {
        rethrow;
      }
      throw OrderException('UNKNOWN_ERROR', 'Erreur lors du calcul des top produits: $e');
    }
  }

  /// üìà R√âCUP√âRER LES DONN√âES DU GRAPHIQUE (utilise maintenant les commandes)
  Future<List<RevenueChartData>> getRevenueChart({int days = 7}) async {
    try {
      print('üìà [STATS] Calcul du graphique des ventes ($days jours) depuis les commandes');
      
      final merchantOrders = await _orderService.getMerchantOrders();
      final chartData = _generateRevenueChartFromOrders(merchantOrders);
      
      print('‚úÖ [STATS] Donn√©es graphique calcul√©es: ${chartData.length} points');
      return chartData;
      
    } catch (e) {
      if (e is OrderException) {
        rethrow;
      }
      throw OrderException('UNKNOWN_ERROR', 'Erreur lors du calcul du graphique: $e');
    }
  }

  /// üîÑ RAFRA√éCHIR LES STATISTIQUES
  Future<MerchantStats> refreshStats() async {
    print('üîÑ [STATS] Rafra√Æchissement forc√© des statistiques');
    return await getMerchantStats(forceRefresh: true);
  }

  /// üìä OBTENIR LES STATS DEPUIS LE CACHE (Si disponible)
  MerchantStats? getCachedStats() {
    if (_isValidCache()) {
      print('üìä [STATS] Retour des stats depuis le cache');
      return _cachedStats;
    }
    return null;
  }

  /// üîç M√âTHODE DE D√âBOGAGE CORRIG√âE
  Future<void> debugMerchantStats() async {
    try {
      print('üîç [STATS] === D√âBOGAGE STATISTIQUES MARCHAND ===');
      
      final isLoggedIn = await isUserLoggedIn();
      print('üë§ [STATS] Utilisateur connect√©: $isLoggedIn');
      
      if (isLoggedIn) {
        try {
          // Test de r√©cup√©ration des commandes d'abord
          final orders = await _orderService.getMerchantOrders();
          print('üì¶ [STATS] Commandes r√©cup√©r√©es: ${orders.length}');
          
          // Puis calcul des statistiques
          final stats = await getMerchantStats();
          print('üìä [STATS] === R√âSULTATS ===');
          print('üí∞ [STATS] CA Total: ${stats.formattedTotalRevenue}');
          print('üì¶ [STATS] Total Commandes: ${stats.totalOrders}');
          print('‚è≥ [STATS] En Attente: ${stats.pendingOrders}');
          print('‚úÖ [STATS] Confirm√©es: ${stats.confirmedOrders}');
          print('üöö [STATS] Exp√©di√©es: ${stats.shippedOrders}');
          print('üìã [STATS] Livr√©es: ${stats.deliveredOrders}');
          print('‚ùå [STATS] Annul√©es: ${stats.canceledOrders}');
          print('üìà [STATS] Taux Succ√®s: ${stats.formattedSuccessRate}');
          print('üí≥ [STATS] Panier Moyen: ${stats.formattedAverageOrderValue}');
          print('üèÜ [STATS] Top Produits: ${stats.topProducts.length}');
          print('üìã [STATS] Commandes R√©centes: ${stats.recentOrders.length}');
          
          // D√©boguer les commandes r√©centes
          for (var order in stats.recentOrders.take(3)) {
            print('   üì¶ Commande #${order.id}: ${order.clientName} - ${order.clientPhone} - ${order.formattedTotalAmount}');
          }
          
          print('========================================');
        } catch (e) {
          print('‚ùå [STATS] Erreur lors du d√©bogage: $e');
        }
      }
    } catch (error) {
      print('‚ùå [STATS] Erreur lors du d√©bogage des statistiques: $error');
    }
  }

  /// ‚ö†Ô∏è GESTION D'ERREURS CONVIVIALES
  String getErrorMessage(dynamic error) {
    if (error is OrderException) {
      switch (error.code) {
        case 'NOT_LOGGED_IN':
          return 'Vous devez √™tre connect√© pour voir les statistiques';
        case 'SESSION_EXPIRED':
          return 'Votre session a expir√©. Reconnectez-vous.';
        case 'NO_INTERNET':
          return 'Pas de connexion internet. V√©rifiez votre r√©seau.';
        case 'TIMEOUT':
          return 'Le serveur ne r√©pond pas. R√©essayez plus tard.';
        case 'NOT_MERCHANT':
          return 'Acc√®s r√©serv√© aux marchands';
        case 'PARSE_ERROR':
          return 'Erreur de communication avec le serveur';
        default:
          return error.message;
      }
    }
    return 'Une erreur inattendue est survenue';
  }

  /// V√©rifier si une d√©connexion est n√©cessaire
  bool shouldLogoutOnError(OrderException error) {
    return error.code == 'SESSION_EXPIRED' || 
           error.code == 'NOT_LOGGED_IN';
  }

  // =====================================================
  // M√âTHODES PRIV√âES UTILITAIRES
  // =====================================================

  /// Formater une date pour les cl√©s de cache
  String _formatDateKey(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  /// V√©rifier si le cache est valide
  bool _isValidCache() {
    if (_cachedStats == null || _lastCacheTime == null) {
      return false;
    }
    
    final now = DateTime.now();
    final cacheAge = now.difference(_lastCacheTime!);
    
    return cacheAge < _cacheValidDuration;
  }

  /// Mettre en cache les statistiques
  void _cacheStats(MerchantStats stats) {
    _cachedStats = stats;
    _lastCacheTime = DateTime.now();
    print('üíæ [STATS] Statistiques mises en cache');
  }

  /// Vider le cache
  void _clearCache() {
    _cachedStats = null;
    _lastCacheTime = null;
    print('üóëÔ∏è [STATS] Cache vid√©');
  }

  /// V√©rifier le code de statut HTTP
  bool _isSuccessStatusCode(int statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }

  /// Parser la r√©ponse d'erreur
  Map<String, dynamic> _parseErrorResponse(String responseBody) {
    try {
      return json.decode(responseBody);
    } catch (e) {
      return {
        'message': 'Erreur de r√©ponse du serveur',
        'code': 'PARSE_ERROR'
      };
    }
  }

  /// Nettoyer les ressources
  void dispose() {
    _clearCache();
    print('üßπ [STATS] MerchantStatsService nettoy√©');
  }
}